RefChain MVP 项目
1. 技术栈概述
前端技术
* 框架: Next.js（React框架）
* 样式: Tailwind CSS
* 状态管理: React Context API
* 钱包集成: Magic.link（无缝Web3钱包体验）
* 图表: Recharts
* HTTP客户端: Axios
* 表单处理: React Hook Form
* 通知: React Hot Toast
后端技术
* 框架: Node.js + Express
* 数据库: Supabase (PostgreSQL)
* 认证: Supabase Auth + Magic.link集成
* Web3集成: ethers.js
* API验证: Joi
* 短链接生成: nanoid
区块链/智能合约
* 网络: Polygon Amoy（测试网）
* 合约标准: ERC-1155（多商户积分）
* 开发框架: Hardhat
* 合约语言: Solidity 0.8.20
* 权限管理: OpenZeppelin AccessControl
2. 系统架构
RefChain MVP采用三层架构设计，包括:
1. 前端层 - 提供用户界面
2. 后端服务层 - 处理业务逻辑和数据持久化
3. 区块链层 - 提供点数的真正所有权和透明度
用户界面 (Next.js)
    │
    ▼
后端API (Express)
    │
 ┌───┴─────────────┐
 │ Supabase (PostgreSQL)
 └───┬─────────────┘
     ▼
Polygon Amoy (区块链)
     │
 智能合约:
 - MultiMerchantPoints (ERC-1155)
3. 数据模型
Supabase数据表
商户表 (merchants)
sql
CREATE TABLE merchants (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE,
  wallet_address TEXT NOT NULL UNIQUE,
  merchant_on_chain_id INTEGER UNIQUE,
  cashback_percentage DECIMAL DEFAULT 5.0 CHECK (cashback_percentage >= 0 AND cashback_percentage <= 100),
  referral_reward_percentage DECIMAL DEFAULT 2.0 CHECK (referral_reward_percentage >= 0 AND referral_reward_percentage <= 100),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);


-- 创建索引
CREATE INDEX merchants_email_idx ON merchants (email);
CREATE INDEX merchants_wallet_address_idx ON merchants (wallet_address);
推荐链接表 (referrals)
sql
CREATE TABLE referrals (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  code TEXT NOT NULL UNIQUE,
  merchant_id UUID NOT NULL REFERENCES merchants(id),
  referrer_email TEXT NOT NULL,
  referrer_wallet_address TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  uses INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT referrals_merchant_fk FOREIGN KEY (merchant_id) 
    REFERENCES merchants(id) ON DELETE CASCADE
);


-- 创建索引
CREATE INDEX referrals_code_idx ON referrals (code);
CREATE INDEX referrals_merchant_id_idx ON referrals (merchant_id);
订单表 (orders)
sql
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  order_code TEXT NOT NULL UNIQUE,
  merchant_id UUID NOT NULL REFERENCES merchants(id),
  merchant_on_chain_id INTEGER NOT NULL,
  amount DECIMAL NOT NULL CHECK (amount >= 0),
  referral_code TEXT,
  referrer_id UUID,
  buyer_email TEXT NOT NULL,
  buyer_wallet_address TEXT,
  points_earned INTEGER DEFAULT 0,
  referrer_points_earned INTEGER DEFAULT 0,
  transaction_hash TEXT,
  status TEXT CHECK (status IN ('pending', 'processing', 'completed', 'failed')) DEFAULT 'pending',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT orders_merchant_fk FOREIGN KEY (merchant_id) 
    REFERENCES merchants(id) ON DELETE CASCADE,
  CONSTRAINT orders_referrer_fk FOREIGN KEY (referrer_id) 
    REFERENCES referrals(id) ON DELETE SET NULL
);


-- 创建索引
CREATE INDEX orders_order_code_idx ON orders (order_code);
CREATE INDEX orders_merchant_id_idx ON orders (merchant_id);
CREATE INDEX orders_buyer_email_idx ON orders (buyer_email);
CREATE INDEX orders_referral_code_idx ON orders (referral_code);
CREATE INDEX orders_status_idx ON orders (status);
创建触发器维护updated_at字段
sql
-- 创建函数更新updated_at
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- 为merchants表创建触发器
CREATE TRIGGER update_merchants_modtime
BEFORE UPDATE ON merchants
FOR EACH ROW EXECUTE FUNCTION update_modified_column();
```


### 区块链数据模型


#### MultiMerchantPoints智能合约
- 基于ERC-1155的多商户积分合约
- 每个商户拥有唯一的tokenId
- 拥有MINTER_ROLE角色可以铸造积分
- 包含铸造点数、批量铸造和余额查询功能


## 4. Supabase集成


### 设置Supabase


1. **创建Supabase项目**
   - 注册Supabase并创建新项目
   - 记录项目URL和API密钥


2. **配置环境变量**
```
   SUPABASE_URL=https://your-project.supabase.co
   SUPABASE_KEY=your-supabase-service-key
3. 初始化Supabase客户端
javascript
   // src/utils/supabase.js
   const { createClient } = require('@supabase/supabase-js');


   const supabaseUrl = process.env.SUPABASE_URL;
   const supabaseKey = process.env.SUPABASE_KEY;
   const supabase = createClient(supabaseUrl, supabaseKey);


   module.exports = supabase;
后端服务集成
1. 商户操作
javascript
   const supabase = require('../utils/supabase');


   // 创建商户
   async function createMerchant(merchantData) {
     const { data, error } = await supabase
       .from('merchants')
       .insert([merchantData])
       .select();
     
     if (error) throw error;
     return data[0];
   }


   // 获取商户
   async function getMerchant(id) {
     const { data, error } = await supabase
       .from('merchants')
       .select('*')
       .eq('id', id)
       .single();
     
     if (error) throw error;
     return data;
   }
2. 推荐链接操作
javascript
   // 生成推荐链接
   async function createReferral(referralData) {
     const { data, error } = await supabase
       .from('referrals')
       .insert([referralData])
       .select();
     
     if (error) throw error;
     return data[0];
   }
3. 订单操作
javascript
   // 创建订单
   async function createOrder(orderData) {
     const { data, error } = await supabase
       .from('orders')
       .insert([orderData])
       .select();
     
     if (error) throw error;
     return data[0];
   }


   // 获取商户订单
   async function getMerchantOrders(merchantId) {
     const { data, error } = await supabase
       .from('orders')
       .select('*')
       .eq('merchant_id', merchantId)
       .order('created_at', { ascending: false })
       .limit(20);
     
     if (error) throw error;
     return data;
   }
5. API接口设计
后端API端点
商户API
* POST /api/merchants - 创建新商户
* GET /api/merchants - 获取所有商户
* GET /api/merchants/:id - 获取指定商户
* PATCH /api/merchants/:id - 更新商户信息
推荐API
* POST /api/referrals/generate - 生成新的推荐链接
* GET /api/referrals/:code - 获取推荐链接详情
* GET /api/referrals/merchant/:merchantId - 获取商户所有推荐链接
订单API
* POST /api/orders/simulate - 模拟订单(演示用)
* GET /api/orders/merchant/:merchantId - 获取商户的订单账本
* GET /api/orders/:orderCode - 获取订单详情
前端与Supabase直接集成（可选）
除了通过后端API访问数据外，前端也可以直接使用Supabase客户端库：
javascript
// 前端Supabase客户端
import { createClient } from '@supabase/supabase-js'


const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
export const supabase = createClient(supabaseUrl, supabaseKey)


// 示例：获取商户订单数据
async function fetchMerchantOrders(merchantId) {
  const { data, error } = await supabase
    .from('orders')
    .select('*')
    .eq('merchant_id', merchantId)
    .order('created_at', { ascending: false });
    
  if (error) throw error;
  return data;
}
6. 认证与授权
Supabase Auth与Magic.link集成
1. 配置Supabase Auth
   * 启用Email认证
   * 配置密码策略
   * 设置JWT过期时间
2. Magic.link集成
   * 将Magic.link用户关联到Supabase用户
javascript
   // 使用Magic登录后关联Supabase用户
   async function loginWithMagic(email) {
     // 1. 通过Magic.link获取DID Token
     await magic.auth.loginWithMagicLink({ email });
     const didToken = await magic.user.getIdToken();
     
     // 2. 在Supabase中创建会话
     const { data, error } = await supabase.auth.signInWithIdToken({
       provider: 'magic',
       token: didToken,
       email
     });
     
     return data;
   }
3. 前端认证状态管理
javascript
   // 在MagicContext中添加Supabase会话管理
   const [supabaseSession, setSupabaseSession] = useState(null);
   
   useEffect(() => {
     const { data: { subscription } } = supabase.auth.onAuthStateChange(
       (event, session) => {
         setSupabaseSession(session);
       }
     );
     
     return () => subscription.unsubscribe();
   }, []);
7. 用户流程
与之前版本一致，但现在使用Supabase进行数据存储和认证。
8. 3天开发计划
第1天：环境搭建与智能合约
* 设置项目结构和开发环境
* 开发和测试MultiMerchantPoints智能合约
* 在Supabase中创建数据表和关系
* 设置初始RPC和API访问
第2天：后端开发与API
* 实现Supabase数据访问层
* 集成区块链功能
* 创建REST API端点
* 添加基本错误处理和验证
第3天：前端开发与集成
* 构建主要UI组件和页面
* 实现Magic.link与Supabase Auth集成
* 连接前端和后端API
* 创建演示功能和流程
9. Supabase的优势
使用Supabase而非MongoDB有以下优势：
1. SQL的强大性能与关系型结构
   * 使用PostgreSQL提供的强大查询能力
   * 表间关系维护更加严格
   * 事务支持确保数据完整性
2. 内置认证系统
   * 完整的JWT认证
   * 社交登录集成
   * 细粒度的行级安全策略
3. 实时订阅
   * 通过PostgreSQL的LISTEN/NOTIFY实现实时数据更新
   * 无需额外的WebSocket服务器
4. 存储与数据库集成
   * 文件存储与数据库无缝集成
   * 简化商户品牌资源管理
5. 边缘函数
   * 部署无服务器功能
   * 可用于处理区块链回调
10. 未来扩展计划
与之前版本相同，但增加了利用Supabase特性的可能性：
* 使用Supabase实时功能显示积分变更的实时通知
* 利用Supabase存储功能存储商户品牌资产
* 使用Supabase边缘函数处理区块链回调